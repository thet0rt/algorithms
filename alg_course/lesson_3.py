from typing import *
'''
Условие
Дан массив nums. Нужно переместить все нули (0) в конец массива, при этом порядок остальных элементов должен сохраниться.

Необходимо изменять исходный массив напрямую, без создания нового массива для хранения результата.

Пример
Ввод: nums = [2,1,0,0,4,0,9]
Вывод: [2,1,4,9,0,0,0]
'''
nums = [2,1,0,0,4,0,9]
# мое решение
def swap(test_list: List) -> List:
    p1 = len(test_list) - 1
    p2 = len(test_list) - 1
    while p1>=0:
        if test_list[p1] != 0:
            p1 -= 1
            continue
        else:
            i = p2 - p1
            for j in range(i):
                nums[p1+j], nums[p1+j+1] = nums[p1+j+1], nums[p1+j]
            p2 -=1
            p1 -=1
    return test_list

print(swap(nums))

'''
[2,1,0,0,4,3,9]
[0,1,2,3,4,5,6]
p1 = 3
p2 = 6
p2 - p1 = количество итераций
for i in range(3):

3 и 4
4 и 5
5 и 6
'''

# эталонное решение
def move_zeros(nums: List[int]) -> List[int]:
    # указывает на какую позицию поставим следующий элемент не равный 0
    p1 = 0
    # указывает на следующий не нулевой элемент
    p2 = 0
    while p2 < len(nums):
        if nums[p2] != 0:
            nums[p1], nums[p2] = nums[p2], nums[p1]
            p1 += 1
        p2 += 1
    return nums


'''
Дан список s, представляющий URL-адрес (буквы и пробелы). Нужно заменить все пробелы в первых k символах на %20, используя свободное место в конце списка и вернуть изменённый список s в качестве ответа.

Пример 1:

Ввод: s = ["h","e","l","l","o"," ","w","o","r","l","d","#","#"], k = 11
Вывод: ["h","e","l","l","o","%","2","0","w","o","r","l","d"]
Пример 2:

Ввод: s = ["a"," ","b"," ", " ", "c","#","#","#","#","#","#"], k = 6
Вывод: ["a","%","2","0","b","%","2","0","%","2","0", "c"]
Ограничения:

len(s) >= 1
k <= len(s)
s всегда имеет достаточно места для размещения
'''

from typing import *

# мое решение
def urlify(s: List[str], k: int) -> List[str]:
    p1 = 0
    p2 = len(s) - 1
    while p1 < k:
        if s[p1] != ' ':
            p1 += 1
            continue
        rasst = p2 - p1-1
        s[p1] = '%'
        for i in range(2):
            print(i)
            p3 = p2
            for j in range(rasst):
                s[p3], s[p3-1] = s[p3-1], s[p3]
                p3-=1
            if i == 0:
                s[p3] = '0'
            else:
                s[p3] = '2'
        p1+=1
        k+=2
    return s

# print(urlify(["h","e","l","l","o"," ","w","o","r","l","d","#","#"], 11))
# print(urlify(["a"," ","b"," ", " ", "c","#","#","#","#","#","#"], 6))

from typing import *

# эталонное решение
def urlify(s: List[str], k: int) -> List[str]:
    # медленный указатель - куда ставим символ
    slow = len(s) - 1
    # быстрый указатель - откуда берем символ
    fast = k - 1

    while fast >= 0:
        # если символ не пробел, то
        #  дублируем значение на новое место
        if s[fast] != " ":
            s[slow], s[fast] = s[fast], s[slow]
            slow -= 1
            fast -= 1
            continue

        # если символ пробел, заменяем его на %20
        s[slow - 2] = "%"
        s[slow - 1] = "2"
        s[slow] = "0"
        slow -= 3
        fast -= 1
    return s

# urlify(["h","e","l","l","o"," ","w","o","r","l","d","#","#"], 11)
# urlify(["a"," ","b"," ", " ", "c","#","#","#","#","#","#"], 6)
# urlify(["h","e","l","l","o"," ","#","#","w","o","r","l","d"], 11)
'''
Декодирование URL-адреса
средне
# решено

# вк
Дан список s. Нужно заменить все вхождения %20 на пробелы в списке s, а оставшиеся лишние символы заменить на #, сохранив длину списка. В качестве ответа верни изменённый список s.

Пример 1:

Ввод: s = ["h","e","l","l","o","%","2","0","w","o","r","l","d"]
Вывод: ["h","e","l","l","o"," ","w","o","r","l","d","#","#"]
Пример 2:

Ввод: s = ["a","%","2","0","b","%","2","0","%","2","0", "c"]
Вывод: ["a"," ","b"," ", " ", "c","#","#","#","#","#","#"]
Ограничения:

len(s) >= 1
'''
# мое решение
def unurlify(s: List[str]) -> List[str]:
    slow = 0
    fast = 0
    while fast < len(s):
        print(s)
        if s[fast] != '%':
            s[slow], s[fast] = s[fast], s[slow]
            slow +=1
            fast +=1
            continue
        s[fast] = ' '
        s[fast+1] = '#'
        s[fast+2] = '#'
        s[slow], s[fast] = s[fast], s[slow]
        fast += 3
        slow +=1
    print(s)
    return s

# s = ["h","e","l","l","o","%","2","0","w","o","r","l","d"]
#
# unurlify(s)
# unurlify(["a","%","2","0","b","%","2","0","%","2","0", "c"])

# эталонное решение
def unurlify(s: List[str]) -> List[str]:
    # медленный указатель - куда ставим символ
    slow = 0
    # быстрый указатель - откуда берем символ
    fast = 0

    while fast < len(s):
        # если встречаем %20, то заменяем на пробел
        if fast + 2 < len(s) and s[fast] == "%" and s[fast + 1] == "2" and s[fast + 2] == "0":
            s[slow] = " "
            slow += 1
            fast += 3
            continue

        # если нет последовательности %20, то копируем символ
        s[slow] = s[fast]
        slow += 1
        fast += 1

    # затираем лишние символы
    for i in range(slow, len(s)):
        s[i] = "#"
    return s

'''
Удаление дубликатов 2
легко

# озон
Пример 1:

Дан массив nums, состоящий из целых чисел. Требуется изменить исходный массив, удалив все дубликаты элементов так, чтобы осталось только первое вхождение каждого уникального значения. Порядок оставшихся элементов должен сохраниться.

В качестве результата верните измененный массив nums.

Ввод: nums = [3,2,1,1,0,4,5,2,0]
Вывод: [3,2,1,0,4,5]
Пример 2:

Ввод: nums = [1,1,1,1]
Вывод: [1]
Ограничения

len(nums) >= 0
'''



'''
Поиск дубликата
средне

# озон
Дан массив nums, содержащий n + 1 чисел, каждое из которых находится в диапазоне от 1 до n. Требуется найти число, которое повторяется более одного раза. Нельзя модифицировать массив или использовать дополнительную память.

Пример 1:

Ввод: nums = [3,1,3,4,2]
Вывод: 3
Пример 2:

Ввод: nums = [1,1]
Вывод: 1
Ограничения:

len(nums) >= 2
1 <= nums[i] <= len(nums)
'''


'''
Минимальная разность
легко

# дзен

# желтый банк

# яндекс
Даны два массива целых чисел nums1 и nums2. Найдите минимальное значение выражения |a - b|, где a — элемент nums1, b — элемент nums2.

Пример 1:

Ввод: nums1 = [1,15,3], nums2 = [21,10,30]
Вывод: 5
Объяснение: |15 - 10| = 5
Пример 2:

Ввод: nums1 = [-5,0,6], nums2 = [10,-2,3]
Вывод: 2
Объяснение: |0 - (-2)| = 2
Ограничения:

len(nums1) >= 1
len(nums2) >= 1
'''


'''
Удаление повторов
легко

# озон
Дан массив целых чисел nums, отсортированный в неубывающем порядке. Удалите из него все дубликаты так, чтобы каждый элемент встречался только один раз. Изменения выполняйте в исходном массиве, не создавая новый. Верните изменённый массив, отсортированный по возрастанию.

Пример 1:

Ввод: nums = [1,1,2,2,3,3,4]
Вывод: [1,2,3,4]
Пример 2:

Ввод: nums = [1,1,1,1]
Вывод: [1]
Пример 3:

Ввод: nums = [10]
Вывод: [10]
Ограничения:

len(nums) >= 1
'''


'''
Похожие строки
средне

# яндекс
Даны две строки s и t. Строки считаются похожими, если они уже равны или могут стать равными после ровно одного изменения: вставки, удаления или замены одного символа. Нужно вернуть true, если строки похожи, иначе — false.

Пример 1:

Ввод: s = "iq", t = "ieq"
Вывод: true
Объяснение: можно добавить один символ и получить равные строки s = t
Пример 2:

Ввод: s = "qwe", t = "qwe"
Вывод: true
Пример 3:

Ввод: s = "abcd", t = "abcdef"
Вывод: false
Объяснение: Необходимо добавить два символа, чтобы строки стали равны.
Ограничения:

len(s) >= 0
len(t) >= 0
'''


'''
Общий префикс
легко

# яндекс
Дан массив строк strs. Нужно вернуть самую длинную строку, которая является префиксом всех строк из strs. Если общего префикса нет, верни пустую строку "".

Пример 1:

Ввод: strs = ["present","predicate","prepare"]
Вывод: "pre"
Пример 2:

Ввод: strs = ["dog","cat","bike"]
Вывод: ""
Объяснение: нет общего префикса.
Ограничения:

len(strs) >= 1
len(strs[i]) >= 1
'''

'''
Сумма отклонений
средне

# авито
Даны два массива целых чисел: nums1 и nums2. Для каждого элемента из nums2 найдите ближайшее по значению число в массиве nums1 и вычислите модуль разности между ними. Верните сумму всех этих разностей.

Пример 1:

Ввод: nums1 = [9,3,6,100], nums2 = [3,8,7]
Вывод: 2
Объяснение:
Для числа 3 ближайшее 3 (|3 - 3| = 0)
Для числа 8 ближайшее 9 (|8 - 9| = 1)
Для числа 7 ближайшее 6 (|7 - 6| = 1)
Ответ: 0 + 1 + 1 = 2
Пример 2:

Ввод: nums1 = [50], nums2 = [10,20,30,40]
Вывод: 100
Ограничения:

len(nums1) ≥ 1
len(nums2) ≥ 1
'''

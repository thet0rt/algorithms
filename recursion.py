def countdown(i: int):
    print(i)
    if i - 1 >= 0:
        countdown(i - 1)


countdown(10)


def fact(x: int):
    if x == 1:
        return 1
    return x * fact(x-1)


print(fact(10))

'''
Просуммировать массив чисел [2, 4, 6]
Как сделать это рекурсивно?

1. Определить базовый случай:
    - Самый простой массив - массив с 0 или 1 элементами
    - [] = 0
    - [7] = 7
'''


def sum(data: list):
    if not data:
        return 0
    elem = data.pop(0)
    return elem + sum(data)


print(sum([1, 2, 5, 7]))


'''
Быстрая сортировка.
Стратегия решения задач "Разделяй и властвуй":
    - определить простейший случай как базовый
    - свести задачу к базовому случаю

Базовый случай быстрой сортировки:
    - [] - пустой массив, его сортировать не нужно
    - [20] - массив с одним элементом    
    
Алгоритм быстрой сортировки:
    - Выбираем опорный элемент
    - Находим элементы, которые > оп. элемента
    - Находим элементы, которые < оп. элемента
    
Этот процесс называется разделение.
Результат разделения:
    - подмассив элементов > ОПЭ
    - ОПЭ
    - подмассив элементов < ОПЭ

Далее рекурсивно проделываем то же самое с левым и правым подмассивами до тех пор, пока не дойдет до базового случая.

О-большое в быстрой сортировке зависит от выбора опорного элемента.
O nlog2(n)
'''


def quick_sort(data: list):
    if len(data) < 2:
        return data
    pivot = data[0]
    less = [i for i in data[1:] if i <= pivot]
    greater = [i for i in data[1:] if i > pivot]
    return quick_sort(less) + [pivot] + quick_sort(greater)


print()